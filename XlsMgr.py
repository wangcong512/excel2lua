# -*- coding:utf-8 -*-

import xlrd
import os
import time
import HeaderCell
import json
import sys
from xlrd import sheet

import sys
reload(sys)
sys.setdefaultencoding('utf8')

# class CateRow(Enum):
#     Group = 1,
GROUP_ROW = 0
KEY_ROW = 1
TYPE_ROW = 2
CONTROL_ROW = 3
NAME_ROW = 4
REMARK_ROW = 5
DATA_ROW = 6

DataType = {
    'INT32': 'int32',
    'INT8': 'int8',
    'STRING': 'string',
    'JSON': 'json',
    'SHEET': 'sheet',
}

ControlType = {
    'KEY': '[KEY]',
    'NODE': '[NODE]',
    'NO': '[NO]',
    'SEED': '[SEED]',
    'PD': '[PD]',
    'OPT': '[OPT]',
    'LINK': '[LINK]',
    'SHEET': '[SHEET]',

}

class XlsMgr(object):
    """
    xls 解析类'''
    """
    m_workbook = None
    m_main_sheet = None
    m_xls_name = ""
    group_list = []
    group_dic = {}
    key_list = []
    type_list = []
    control_list = []



    def __init__(self):
        pass

    def load_xls(self, file_name):
        # 打开文件
        self.m_xls_name = file_name
        self.m_workbook = xlrd.open_workbook(file_name)
        sheet_names = self.m_workbook.sheet_names()
        self.m_main_sheet = self.m_workbook.sheet_by_name('main')

    def write_header(self, file_name):
        header_str = "-- NAME:{name}\n".format(name = file_name)
        header_str += "-- TIME:{time}\n".format(time = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))
        header_str += "-- Generated by editor\n\n"
        header_str += "GameData = GameData or {}\n"
        header_str += 'GameData.{} = '.format(file_name)
        return header_str

    def write_tail(self):
        tail_str = "}\n"
        return tail_str

    def get_dic2lua(self,dic):
        pass

    def get_dic2json(self):
        pass

    def cell2lua(self,cell_key, data_type, row_val, col_val,sheet_tb):
        cell_str = ""
        cell = sheet_tb.cell(row_val, col_val)
        # print str(cell).decode("unicode_escape").encode("utf-8"),
        # lua_file.write(str(cell).decode("unicode_escape").encode("utf-8"))
        cell_val = cell.value
        cell_type = cell.ctype
        print "gen_sheet_name:",sheet_tb.name
        if data_type == DataType['STRING']:
            if cell_type == 3:
                date_time = xlrd.xldate_as_datetime(cell_val, 0)
                time_str = date_time.strftime("%Y-%m-%d-%H-%M-%S")
                cell_str = "{} = \"{}\",\t".format(cell_key, time_str)
            elif cell_type == 2:
                cell_str = '{} = \"{:d}\",\t'.format(cell_key, int(cell_val))
            else:
                cell_str = "{} = \"{}\",\t".format(cell_key, str(cell_val).encode("utf-8"))
        elif data_type == DataType['INT8'] or data_type == DataType['INT32']:
            data_val = 0
            if cell_type == 2:
                data_val = '{:d}'.format(int(cell_val))
            else:
                data_val = '{}'.format(str(cell_val).decode("unicode_escape").encode("utf-8"))
            if data_val == "":
                data_val = "0"#数字类型的强制赋值个0

            cell_str = "{key} = {val:s},\t".format(key = cell_key, val = data_val)
        elif data_type == DataType['JSON']:#json 数据
            # print 'curent coding:', sys.getdefaultencoding()
            json_str = cell_val
            if json_str == '':
                pass
            else:
                cell_str = "{} = {},\t".format(cell_key, self.json2lua_tb(json_str))
        elif data_type == DataType['SHEET']:
            sheet_name = cell_val.encode("utf-8")
            sub_sheet_tb = self.m_workbook.sheet_by_name(sheet_name)
            cell_str = "{} = {},\t".format(cell_key, self.gen_sheet2lua(sub_sheet_tb, None))


        return cell_str


    def cell2json(self, row_val, col_val):
        pass

    def json2lua_tb(self, json_data):

        data_obj = json.loads(json_data)
        lua_str = self.json_obj_parser(data_obj)
        return lua_str


    def json_obj_parser(self, json_obj):
        for v in json_obj:
            lua_str = '{ '
            if type(v) == dict:
                for key in v:
                    if type(v[key]) != list and type(v[key]) != tuple:
                        lua_str += "{} = {},".format(key, v[key])
                    else:
                        lua_str += "{} = ".format(key)
                        lua_str += self.json_obj_parser(v[key])
            lua_str += ' }'
        return lua_str

    def gen_lua(self):
        gen_file_name = self.m_xls_name[0:self.m_xls_name.find(".xlsx")]
        lua_file_name = self.m_xls_name[0:self.m_xls_name.rfind(".xlsx")] + ".lua"

        lua_file = open(lua_file_name, 'wb')
        lua_file.write(self.write_header("npc"))
        lua_file.write(self.gen_sheet2lua(self.m_main_sheet, lua_file))



    def gen_sheet2lua(self, sheet_tb, out_file):
        key_list = sheet_tb.row_values(KEY_ROW)
        group_key_list = sheet_tb.row_values(GROUP_ROW)
        control_list = sheet_tb.row_values(CONTROL_ROW)
        type_list = sheet_tb.row_values(TYPE_ROW)
        first_cols = sheet_tb.col_values(0)
        max_rows = len(first_cols)
        max_cols = len(group_key_list)
        start_tab = ""
        out_buf = ""
        #
        for v in xrange(max_cols -1, -1, -1):
            group_key = group_key_list[v]
            if group_key == "END":
                max_cols = v
                break
        for v in xrange(max_rows -1, -1, -1):
            row_key = first_cols[v]
            if row_key == "END":
                max_rows = v
                break
        group_list = []
        group_dic = {}
        for v in xrange(max_cols):
            if v == 0:
                continue
            group_key = group_key_list[v]
            key = key_list[v]

            if group_dic.has_key(group_key):
                second_data = group_dic[group_key]
                second_data[key] = v
            else:
                group_dic[group_key] = {key: v}

        control_dic = {}
        for v in xrange(len(control_list)):
            control_dic[control_list[v]] = v
        index_key = '[KEY]'.upper()
        key_cols = control_dic['[KEY]']

        # out_file.write("{\n")
        out_buf += "{\n"
        start_tab += "\t"
        for row_val in xrange(max_rows):
            if row_val < DATA_ROW:
                continue
            data_val = {}
            main_key = sheet_tb.cell(row_val, key_cols).value.decode("unicode_escape").encode("utf-8")
            # out_file.write(start_tab + "[\"{key}\"] = ".format(key = main_key) + "{ ")
            out_buf += (start_tab + "[\"{key}\"] = ".format(key=main_key) + "{ ")
            for group_key in group_dic:
                head_data = group_dic[group_key]
                control_key = ""
                if len(head_data) == 1:
                    for key_val in head_data:
                        col_val = head_data[key_val]
                        control_key = control_list[col_val]

                if len(head_data) == 1 and control_key != "[SEED]":#单个数据直接key-value
                    for key_val in head_data:
                        col_val = head_data[key_val]
                        cell_data_type = type_list[col_val]
                        if row_val >= DATA_ROW and col_val > 0:
                            # out_file.write(self.cell2lua(key_val, cell_data_type, row_val, col_val))
                            out_buf += self.cell2lua(key_val, cell_data_type, row_val, col_val, sheet_tb)
                else:#如果是多个数据搞成table
                    # out_file.write("{} = ".format(group_key))
                    # out_file.write("{ ")
                    out_buf += "{} = ".format(group_key)
                    out_buf += "{ "
                    for key_val in head_data:
                        col_val = head_data[key_val]
                        cell_data_type = type_list[col_val]
                        if row_val >= DATA_ROW and col_val > 0:
                            # out_file.write(self.cell2lua(key_val, cell_data_type, row_val, col_val))
                            out_buf += self.cell2lua(key_val, cell_data_type, row_val, col_val, sheet_tb)
                    # out_file.write(" }, ")
                    out_buf += " }, "
            # out_file.write(" }")
            # out_file.write("\n")
            out_buf += " }\n"
        # out_file.write("}\n")
        out_buf += "}\n"
        return out_buf